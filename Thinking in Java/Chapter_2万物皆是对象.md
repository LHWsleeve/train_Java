11# 第二章：一切皆是对象

## 2.1 用引用操纵对象

- java一切都是对象，操纵的标识符是对象的一个"引用"。（遥控器--电视机）
- 拥有一个引用，并不一定需要有一个对象与其关联。（String s;）此时，创建了一个引用而非对象，无法向s发送消息，s没有与任何事物关联。创建一个引用同时初始化（String s = "ssssdf";）

## 2.2 必须有你创建所有对象

- 用**new**操作符实现新对象的关联：（String s = **new** String("abc");
   $(# 这行代码究竟创建了几个String对象呢）$
   
   答：一个或两个

    - 首先在堆中（不是常量池）创建一个指定的对象"abc"，并让s引用指向该对象
    - 在字符串常量池中查看，是否存在内容为"abc"字符串对象
    - 若存在，则将new出来的字符串对象与字符串常量池中的对象联系起来
    - 若不存在，则在字符串常量池中创建一个内容为"abc"的字符串对象，并将堆中的对象与之联系起来

- 寄存器：速度最快，空间最小。
- 栈:在RAM中，通过指针上移，释放资源，下移加入资源，有较大局限性（必须知道所有项的生命周期），一部分java数据存在栈中（对象的引用），但对象不存在栈中
- 堆： 位于RAM中，用于存放java的对象，编译器不需要知道对象存活时间，有较大灵活性。
- 常量存储 常量值直接放在程序代码内部
- 非RAM存储 数据完全存活于程序之外。如，流对象（字节流）和持久化对象（磁盘）。对象可以转化成可以存放在其他媒介上的十五在需要时可以恢复成常规的基于RAM的对象（使用JDBC，Hibernate）

## 2.3 永远不要销毁对象

- 作用域(scope)：
作用域里定义的变量只可作用于作用域结束之前。Java不允许将一个较大作用域的变量"隐藏"起来的做法。
- 对象的作用域：
Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。
    ```
    String s = new String("xxx");
    ```
    引用s在作用域终点消失，但是s指向的**String**对象任继续占据内存空间。

    并且使用Java垃圾回回收期，来监视用new创建的所有对象，消除内存泄漏问题。

## 2.4 方法、参数和 返回值
Java中的方法只能作为类的一部分来创建。方法只有通过对象才能被调用，且这个对象必须能执行这个方法调用。#（static方法：针对类调用，不依赖于对象存在）

参数列表指定要传递给方法什么样的信息。在参数列表中必须指定$\color{red}{每个所传递对象的类型及名字}$，并且与Java中任何传递对象的场合一样，传递的实际上是 ***对象的引用***。

static关键字：
    
    1.只想为某特定域分配单一空间，而不考虑究竟创建多少对象，甚至可以不创建对象
    2.希望某个方法不与包含它的那个类的任何对象关联在一起

当声明一个static类时，表示该域或方法不会与包含他的哪个类的任何对象实例关联。$\color{green}{即使从未创建某哥类的任何对象或方法，也可以调用其static方法或访问域}$

```
class StaticTest{
    static int i = 1;
}

StaticTest t1 = new StaticTest();
StaticTest t2 = new StaticTest();
```
创建了两个static对象，但是t1.i与t2.i共享同一份空间（验证hashcode一致）即指向相同。

引用static变量：1.通过对象定位
2.通过类名直接引用，对于非静态成员不可。如
```
t1.i++;//由于共享空间，改变之后静态变量值全变，t1，t2都+1
```

# 操作符
 - ！=和==比较的是对象的引用。若想比较对象的实际内容是否相同必须使用：equals()/此方法不适用于基本类型。
  
    $\color{red}{equals()方法的默认行为是比较'引用'，若比较基本类型会出现错误，使用前必须重写equals()}$（不过大多数类库已经实现重写操作）
- 在Java中，不可将一个非布尔值当作布尔值在逻辑表达式中使用，例如10&&8，即只有布尔值可以执行逻辑操作运算(&&，||，！)。
- **按位操作符**：用来操作整数基本数据类型中的单个"比特(bit)"。即二进制。按位操作符会对两个参数中对应的位执行布尔代数运算，并生成结果。

    按位操作符具有逻辑操作符相同的效果，并且不会出现"短路"。异或操作符不包括在逻辑操作符内
    按位操作符|逻辑操作符|值
    -|-|-
    &|&&|与
    \||\|\||或
    ~|!|非
- 位移操作符：操作二进制，只可以用来处理整数类型。(都可以理解为小数点的左右移)

  左移位操作符(<<):能按照操作符右侧指定的位数将操作符左边的操作数向左移动(低位补0).
  
  右移位操作符(>>)：操作符右侧指定的位数将操作符左边的操作数向右移动。有符号数右移位操作符使用符号补位(补码)，Java特有无符号右移操作符(>>>)，无论正负高位补0.
- 字符串操作+和+=：

    **字符串运算规则**：若括号内存在字符串则将整体当作字符串操作，但是内部出现括号时，以括号为优先级先进行运算。
    ```
    print(""+x)；
    ```
    空String+基本类型变量--->等于显式的Integer.toString()方法执行字符串转换。

$\color{red}{注意：Java中不会自动的将int数值转换成布尔值，所以while(x=y)是语法错误}$

## 第五章：初始化与清理

### 5.1 构造器确保初始化

在Java中，通过提供构造器，类的设计者可以确保每个对象都会初始化。创建对象时，如果右构造器，$\color{red}{Java就会在用户有能力操作对象之前自动调用相应的构造器}$，从而保证了初始化的进行。

使构造器名称采用与类相同的名称：

    1.防止构造器名称与其他类名冲突。
    2.使编译器一起知道应该调用某个方法。
构造器可以确保在操作对象之前，已经恰当初始化（默认构造器，即无参构造器或空构造器也是必须的）

**注意**：构造器是一种特殊的方法，没有返回值，但与返回值为void的方法不同。

### 涉及基本类型的重载
小-->大（自动完成，转换为存在的类型中最小的类型）
大-->小（必须在转换前强制转换）

### 5.3 默认构造器
- 如果类中没有构造器，则编译器会自动创建一个无参构造器。若已经定义了任意一个构造器，编译器不会。

### 5.4 this关键字

- 希望在方法内部获得对当前对象的引用。使用this关键字，该关键字只能在方法内部使用，表示：“调用方法的那个对象”。
- 在构造器中调用构造器：其实就是依次实例化
  ![](pic/1.png)

- static内部没有this，static可以在没有实例化的前提下，仅通过类本身调用。

### 5.5 清理
- Java对象并非总是被垃圾回收：

    0.finalize()不能作为通用的清理方法
    
    1.对象可能不被垃圾回收
    
    2.垃圾回收不等于"析构"
- 垃圾回收只与内存有关

### 5.6 成员初始化
Java尽力保证所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，未初始化会报错。

数据基本类型和一定义的一个类的引用除外(本身有默认初值)

### $\color{red}{5.7 构造器初始化}$
-初始化顺序
 在类的内部，变量(对象实例)定义的先后决定了初始化的顺序。即使变量散布在方法任何地方，他们都会在构造器启动之前完成初始化。
- 静态数据的初始化(构造器可以看成静态方法)
  $\color{red}{无论创建多少个对象，static数据只占用一份存储空间。}$静态初始化只有在必要时可才会进行，只有在第一次访问静态数据的时候，才会被初始化，此后改静态对象不会再次被初始化。

  初始化顺序：静态对象--->非静态对象
 
### 5.8 数组初始化
  如果创建一个非基本类型数组，那么就创建了一个$\color{red}{引用数组/数组中使类的引用}$，只不过刚建立的时候引用对象都是null，一定要创建显得对象在内。
  
  采用花括号的形式来初始化列表对象，有两种形式，我们选第二中，可以在任何地方使用。
  ```
  Interger[] b = new Integer[]{2,3,new Integer(1)}
  甚至可以创建一个S听、对象书，将其传递给另一个卖main方法
  Other.main(new String[]{"xx","sss",})
  ```
  
- 可变参数

    ```
    可以直接传入一串对象，或基本类型。编译器会自动包装成数组
    使用print(Object...args)作为参数
    另外编译器会自动将基本类型升格为包装类
    ```
    **注意**：如果函数只使用一个可变参数，可能会使重载的过程变得混乱，最好传入一个不可变参数来辅助。

    ```
    例如：
    void print(Integer...args)--->void print(Integer i,Integer...args)
    ```

- **枚举类型**

当创建枚举类型enum后，系统会自动添加一些特性，如toString()方法，方便显示实例名。ordinal()方便表示常理啊ing顺序，以及xxx.value()产生枚举值的列表，可以以xx类型遍历。

  枚举类型可以直接和switch(enum)搭配使用。

# 访问控制权限

  public

  protected

  默认权限(包权限)

  私有权限

---
  当编写一个Java源代码文件时，此文件通常被称为编译单元。每个编译单元都必须有一个 **.java**文件，在编译单元内可以有一个Public类，该类的**名称必须与文件的名称相同**。每一个编译单元都只能由一个public类，其他类为public类提供支持。

  **如果不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，阻止直接通过构造器创建该类**。

  *但是有例外*：在该类的内部可以用static方法静态创建该类，然后返回该类。通过调用静态方法获得该类的实例。

# 第七章：复用类

1.在新的类中产生现有类的对象。由新的类是由现有类的对象所组成，所以称为**组合**。

2.按照现有类的类型创建新类。**继承**

**每个非基本类型类都有一个toString()方法，当编译器需要一个String而你只有一个对象时，该方法会被调用。**

**初始化引用的位置**：

1.在定义对象的地方。这意味着他们总使能够在构造器被调用之前被初始化

2.在类的构造器中

3.就在正要使用这些对象之前，**惰性初始化**。

## 7.2 继承语法

创建一个类时一定是在继承，不是显式的继承就是隐式继承Object。

$\color{red}{组合是has-a的关系}$，新类是现有类的一种类型，$\color{red}{子类的类型同时也是父类的类型(向上转型)}$

由导出类转型成基类，是从一个较专用的类型向通用的类型转换，因此总是安全的。即，导出类是基类的一个超集。

可以为每个类都创建一个main（）方法。在每个类中都设置一个mian()方法的技术是每个类的单元测试变得简便。

```
    class jilei{
        public void c1(){
            System.out.println("123");
        }
    }

public class jicheng extends jilei{
    public void c1(){
        System.out.println("456");
        super.c1();
    }

    public static void main(String[] args) {
//        jilei jl = new jilei();
//        jl.c1();
        jicheng jc = new jicheng();
        jc.c1();

        output：
        456
        123
```

$\color{red}{super}$:要理解这个super表示超类的意思。在上述代码中，执行jc.c1()先输出456，后输出123，说明执行了c1内部的语句后，根据super.c1右执行了父类同名方法c1的语句。若在c1中直接调用c1，编译器会认为递归，所以使用super关键字，表示超类，即，执行继承父类的方法。

$\color{red}{在构造器中super就等于该类所继承的父类本身}$：对于含餐的基类，我们使用super（i）向父类传参初始化。例如

```
class Game{
    Game(int i){
        System.out.prinln(i);
    }
}
class BigGame extends Game{
    spuer(i)// 必须先为Game基类构造器初始化，因为继承是先构造基类。不然会失败
    System.out.println(“xxx”)
}
```

## 7.2 代理

继承与组合的中庸之道。

组合：创建两个分离的类，在一个类中引用另一个类

继承：在基类外部创建一个大类包裹基类。$\color{red}{组合是is-a的关系}$

代理：在代理类中创建某功能的类，调用类的一些方法以获得该类的部分特性。
**用处**：需要使用基类的方法，但又不想暴露所有方法。

例如：飞机控制类，我不想暴露太多飞机控制的功能，只需部分前进左右转的控制（而不需要暴露发射导弹功能）。通过在代理类中new一个飞机控制对象，然后在方法中添加飞机控制类的各个需要暴露的功能。

```
public class PlaneDelegation{
     private PlaneControl planeControl;    //private外部不可访问
     /*
      * 飞行员权限代理类，普通飞行员不可以开火
      */
     PlaneDelegation(){
         planeControl=new PlaneControl();
     }
     public void speed(){
         planeControl.speed();
     }
     public void left(){
         planeControl.left();
     }
     public void right(){
         planeControl.right();
     }
 }

 final class PlaneControl {//final表示不可继承，控制器都能继承那还得了。。
     protected void speed() {}
     protected void fire() {}
     protected void left() {}
     protected void right() {}
 }

```

## 7.5 protected关键字

在项目中我们想将某些事物尽可能的隐藏起来，但仍然允许子类的成员访问他们。ptotected：就类用户而言，这是private，但对于任何一个继承于此父类的类或同一个包内的类都是可见的(也提供包内访问权限)。

## 7.6 final关键字

### 7.6.1 final、数据

向编译器告知某类数据是恒定不变的。在Java中，这类常量必须是基本数据类型，并且以final关键字表示，在对这个常量定义的时候不一定对其赋值（***空白final***）但是在使用前必须初始化。

一个既是static也是final的域(*习惯大写*)，只占一段不能改变的存储空间。

**当final运用在对象的引用的时候**：对于基本类型，final使数值恒定不变，而对于对象的引用，final使引用很定不变。即，一旦引用被初始化指向一个对象，就无法把他改为指向另一个对象。***但是对象本身使可以修改的，只是引用恒定***。

Java允许在参数列表中以声明的方式将参数指明为final：在方法中，参数列表存在final引用，那么在该方法内，无法改变引用所指向的对象。即**无法被重写**。

### 7.6.2 使用final方法的原因

- 把方法锁定，以防止任何继承类修改它的含义。
- 性能，现在不用了。在现在的java中，应该让编译器和JVM去处理效率问题，只有在想要明确禁止覆盖时，才将方法设置为final。
  
**类中所有的private方法都隐式的指定为final**(无法取用private，也就无法重写)，可以对private增加final，但此操作无任何意义。

***注：***没有@override注解时，在继承中覆写final方法(private隐含final)并不会报错，实际上时重新创建了一个同名方法。实际上继承内不会加载private的方法。private不是基类的向外暴露的接口。

### 7.6.3 final类

将final关键字放在类前，将类整体定义为final时，该类无法被继承，即该类永不需要被变动，或不希望拥有子类。**并且final类中的所有方法都隐式的指定为final方法。**

## 7.7初始化及类的加载

Java中所有的事物都是对象，每个类的编译代码都存在于他自己的独立文件中。该文件只在需要使用程序代码时才会被加载。***类的代码在初次使用时菜价在***=加载发生于创建类的第一个对象之时，但当访问static时也会加载，又因为：

***类的构造器时隐式的static，所以更准确的将，类是在其任何static成员被访问时加载的***

## 7.8 总结

继承和组合都能从现有类型生成新类型，组合一般是将现有类型作为新类型底层实现的一部分来加以复用，而继承复用的时接口。

使用继承时，因为导出类具有基类的接口，因此它可以向上转型至基类。***但是***，尽管面向对象对继承极力强调，但是一般优先选择组合或者代理，必要时才使用继承。

# 第八章 多态

继承允许对象视为他自己本身的类型或其基类的类型来加以处理，它允许将多种类型(从同一基类导出)视为同一类型来处理，这样同一分代码可以无差别的运行在同一类型之上。 

## 方法调用绑定

将一个方法调同一个方法主体关联起来被称作绑定。
- 若在程序执行前进行绑定，前期绑定
- 在运行时根据对象的类型进行绑定：后期绑定(动态绑定或运行时绑定)。若想实现动态绑定，必须具有某种机制，能再运行时能判断对象的类型，从而调用恰当的方法。

**Java中除了static和final方法，其他都是后期绑定**。所以将某个方法声明为final可以关闭动态绑定，编译器就不需要判定对象类型，从而增加效率(实际没啥)。

## 产生正确行为

因为java中非final，static方法都是动态绑定实现多态，我么可以编写只与基类打交道的程序代码，并且这些代码对于所有的导出类都可以正确运行。我们只需要将消息发送给对象，由对象自己判断做什么。

### 多态的缺陷：域与静态方法

1.只有普通的方法调用可以是多态的。但一般不会出现

2.静态方法不具有多态性。静态方法可继承可覆写，但是使用多态使只会显示父类方法。

静态方法只与类而非单个对象相关联。

## 构造器和多态

构造器本质使static方法，所以其并没有多态性之。

**构造器的调用顺序**：基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接。因为导出类通常只能检查自己类中成员，不能访问基类成员(private)，只有基类的构造器才具有权限对内部成员初始化。

**继承和清理**：通过组合和继承的方法来创建新类，不需要担心对象的清理问题，子对象留给垃圾回收器处理。

对于清理：销毁的顺序应该和初始化顺序相反：意味着与声明顺序相饭；先清理导出类，在清理基类。

***构造器内部的多态方法的行为**：

<font color="red">***初始化实际过程:***</font>

1. 在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制零。
2. 如前所述那样构造基类构造器。此时，调用被覆盖后的draw()方法，由于步骤1的缘故，我们会发现radius=0.（P.163）
3. 按照声明顺序调用成员的初始化方法
4. 调用导出类的构造器主体

### 协变返回类型

协变返回类型：在导出类中的被重写的基类方法可以返回基类方法的返回类型。

### 向下转型与运行时类型识别

向上转型使安全的，只是可能会丢失方法。

我们必须要有某种方法来确保向下转型的正确性。(RTTI)运行时类型识别，java自带。向下转型错误时抛出异常。

# 9.接口

接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。

## 9.1 抽象类和抽象方法

抽象类使普通的类和接口之间的中庸之道。
为Java提供一个机制：为类的所有导出类创造一个*通用接口*。该方式叫做**抽象方法**，这种方法是不完整的；仅有声明而没有方法体。

    abstract void f();
包含抽象方法的类叫做**抽象类**；如果一个类包含一个或多个抽象方法，那该类必须被定义成**抽象类abstract。**

<font color="blue">**但是，抽象类中的方法并不全是抽象的**</font>,将需要抽象的方法抽象即可。

如果一个类继承于抽象类，并想创建改新类的对象，则必须为基类中所有的抽象方法提供方法定义。如果不这么做，那么导出类也是**抽象类**，并且必须加上abstract关键字。

## 9.2 接口

interface关键字使抽象的概念更进一步。abstract关键字允许在类中创建一个没有方法体的方法(向外的接口)，这些方法的实现是由继承者创建的。

interface关键字使产生一个完全彻底抽象的类，完全不提供具体实现。允许创建者确定，**方法名、参数列表和返回类型**但是没有任何方法体。接口只提供形式，不提供任何实现。

<font color="red">**接口默认权限为public**</font>

interface允许类似多重继承的实现(Java中没有多继承)，同一个类可以实现或者说继承多个接口。

## 9.3 完全解耦

以接口的方式同一相似的任务，将接口和更多的不同的具体实现类联系起来

## 9.4 接口的多重继承

若知道某事物应该成为一个基类，那么第一选择是定义为接口。

## 9.5通过继承来组合接口

- 组合接口是的名字冲突：不要再将会组合在一起的接口中使用相同的方法名，会造成混乱。**方法的重载仅通过返回类型使区分不开的。**
  
## 9.6 适配接口

**允许同一个接口具有多个不同的实现**：一般情况下是一个方法，该方法接受一个实现了的接口类型的类。此时这个接口的实现和像这个方法传递的对象都由程序员决定。

策略模式：编写一个执行某些操作的方法，该方法接受一个实现了指定**接口**的对象。(可以使用任何想要使用的对象来调用方法，只要这个对象遵循指定接口)

我们可以通过同时继承一个类和实现一个接口来适配一个类，这促使我们可以在任何现有类之上添加新的接口。

例如只要继承Readable接口，就可以成为Scanner对象的输入

## 9.7 接口中的域

**放入接口中的任何域都是自动final和static的**，所以接口很方便创建常量组。

## 9.8 嵌套接口（估计没什么卵用..）

## 9.9 接口与工厂

接口是实现多重继承的途径，生成遵循某个接口的对象的典型模式就是*工厂方法*设计模式。

# 第十章 内部类

可以将一个类的定义放在另一个类的定义内部。

最普通的情况：单纯将一个类放在一个大类之内，类似组合。

**典型情况**：外被类有个方法，该方法返回一个指向内部类的引用。如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，必须具体指明这个对象的类型：OuterClass Name.InnerClassName。

## 10.1 链接到外部类

<font color="blue">当生成一个内部类对象时，此时对象与制造他的外围对象之间有了联系，</font>
他能访问外围对象的所有成员，而不需要任何特殊条件。内部类拥有外围类所有元素的访问权限。
<font color="blue">内部类能访问其外围类的放啊和字段，不论权限。 </font>

## 10.2 使用.this和.new

如果要声称对外部类对象的引用，可以使用OuterClass.this，这样产生的引用自动具有正确的类型。

说白了，就是在内部类中使用OuterClass.this就会自动生成对应OuterClass外部类的引用，此时可以直接调用外部类的方法。（调用.this时候，程序又回到外部类中使用方法）

如果外部类中没有内部类的工厂方法(new InnerClass)，则在使用内部类时必须在main中new内部类。我们使用

    OuterClass.new InnweClass();
方式，其他照旧。不能直接new内部类名字，需要引用外部类的对象来创建改内部类对象。

所以，在拥有外部类对象之前是不可能创建内部类的，内部类必须隐式链接到外部类。

**但是静态内部(嵌套类)类除外。**，静态内部类不需要通过外部类的对象创建。<font color="red">静态内部类当外部类创建时自动创建，有且仅创建一次</font>

## 10.5 在方法和作用域内的内部类

可以在方法里面或者在任意的作用域内定义内部类：

1. 实现某类型的接口，可以创建并返回对其的引用
2. 解决复杂问题，可以创建一个类来辅助解决，但又不希望这个类是公共课用的

后面的例子：

    1.一个定义在方法中的类
    2.一个定义在作用域的类，此作用域在方法内部
    3.一个实现了接口的匿名类
    4.一个匿名类，它扩展了有非默认构造器的类。
    5.一个匿名类，他执行字段初始化
    6.一个匿名类，它通过实例初始化实现构造（匿名类不能有构造器）

- 局部内部类：放在一个外部类中一个方法的作用域中。有效范围**仅在有效的作用域内**，比如方法中，或者循环体，判断体中。

## 10.6 匿名内部类

- 匿名内部类在return之后

        return new Contents(){xxx};
        返回一个类的引用，该类继承于Contents并且向上转型为Contents。
- 有参构造器的匿名内部类

        OutClass(int x){
            return new Contents(x){xxx};
        }；
        只需要简单的从外部类传入构造器的默认参数即可
        此方式也可以给匿名内部类中的属性赋值，但是，将要在内部类中使用的参数必须是final型
- 匿名内部类末尾的分号不是用来标记内部类的结束，而是表示表达式的结束。
- 匿名内部类本身没有构造器，但是通过**实例初始化**的方式可以达到构造器的效果。

        比如，返回的匿名内部类继承于一个抽象类，该抽象类拥有构造方法。
        或者说可以从外部类传入final型参数为内部类的属性赋值。

## 10.7 嵌套类

  如果不需要内部对象与外部对象有联系，可以将内部对象设置为static，此时被称为**嵌套类**。此时内部类对象不会隐式保存一个指向外部的引用：

        1.要创建嵌套类的对象，不需要其外部类的对象
        2.不能从嵌套类的对象中访问非静态的外围类对象。
        3.普通内部类的字段和方法只能放在外部层次上，不能有static数据和字段。但是嵌套类可以。

## 10.8 我们为什么需要内部类（2019-12-22）

# 第十一章 持有对象

由于程序可能随时随地任意数量的创建对象，不知道确切类型，Java实用类库提供了容器来解决这个问题。基本类型是**List、Set、Queue、Map**（集合类），通常用容器称呼。

## 11.1 泛型和类型安全的容器
ArrayList:这个容器中保存的是Object，可以添加进任何对象，当从ArrayList中去除对象时，**得到的只是Object对象的引用**，必须要转型为对应的类型。

针对上面的加入任意对象，我们可以预定义的泛型类型(Java泛型创建类会很复杂)。例如**ArrayList\<Apple>**,尖括号括起来的是参数类型，可以有多个。此时从容器中取出对象时不需要转型，编译器清晰的知道，是什么类型。

- **Object有默认的toString方法，该方法的默认操作就是打印类所对因的hashCode**