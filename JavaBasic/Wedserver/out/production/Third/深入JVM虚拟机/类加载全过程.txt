链接 将Java类的二进制代码合并到JVM的运行状态之中的过程

·验证：
-确保加载的类信息符合JVM规范，没有安全方面的问题。

·准备：
-正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配

·解析
-虚拟机常量池内的符号引用替换为直接引用的过程

初始化
·初始化阶段是执行类构造器<clifit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。
·当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化
·虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。
·当访问一个Java类的静态域时，只有真正声明这个域的类才会被初始化。


·类的主动引用（一定会发生类的初始化）
-new一个类的对象
-调用类的静态成员（除了final常量）和静态方法
使用java.lang.reflect包的方法对类进行反射调用
-当虚拟机启动，java Hello，则一定会初始化Hello类。说白了就是先启动main方法所在的类
-当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类

·类的被动引用（不会发生类的初始化）
-当访问一个静态域时，只有真正声明这个域的类才会被初始化（！解释：一般在继承中，若声明的是B父类A的静态属性，那么只会对A初始化）
·通过子类引用父类的静态变量，不会导致子类初始化
-通过数组定义类引用，不会触发此类的初始化
-引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）